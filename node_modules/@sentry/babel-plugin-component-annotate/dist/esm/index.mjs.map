{"version":3,"file":"index.mjs","sources":["../../src/constants.ts","../../src/index.ts"],"sourcesContent":["/**\n * MIT License\n *\n * Copyright (c) 2020 Engineering at FullStory\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nexport const KNOWN_INCOMPATIBLE_PLUGINS = [\n  // This module might be causing an issue preventing clicks. For safety, we won't run on this module.\n  \"react-native-testfairy\",\n  // This module checks for unexpected property keys and throws an exception.\n  \"@react-navigation\",\n];\n\nexport const DEFAULT_IGNORED_ELEMENTS = [\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"bdi\",\n  \"bdo\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"menu\",\n  \"menuitem\",\n  \"meter\",\n  \"nav\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"small\",\n  \"source\",\n  \"span\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n];\n","/**\n * MIT License\n *\n * Copyright (c) 2020 Engineering at FullStory\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\n/**\n * The following code is based on the FullStory Babel plugin, but has been modified to work\n * with Sentry products:\n *\n * - Added `sentry` to data properties, i.e `data-sentry-component`\n * - Converted to TypeScript\n * - Code cleanups\n */\n\nimport type * as Babel from \"@babel/core\";\nimport type { PluginObj, PluginPass } from \"@babel/core\";\n\nimport { DEFAULT_IGNORED_ELEMENTS, KNOWN_INCOMPATIBLE_PLUGINS } from \"./constants\";\n\nconst webComponentName = \"data-sentry-component\";\nconst webElementName = \"data-sentry-element\";\nconst webSourceFileName = \"data-sentry-source-file\";\n\nconst nativeComponentName = \"dataSentryComponent\";\nconst nativeElementName = \"dataSentryElement\";\nconst nativeSourceFileName = \"dataSentrySourceFile\";\n\ninterface AnnotationOpts {\n  native?: boolean;\n  \"annotate-fragments\"?: boolean;\n  ignoredComponents?: string[];\n}\n\ninterface AnnotationPluginPass extends PluginPass {\n  opts: AnnotationOpts;\n}\n\ntype AnnotationPlugin = PluginObj<AnnotationPluginPass>;\n\n// We must export the plugin as default, otherwise the Babel loader will not be able to resolve it when configured using its string identifier\nexport default function componentNameAnnotatePlugin({ types: t }: typeof Babel): AnnotationPlugin {\n  return {\n    visitor: {\n      FunctionDeclaration(path, state) {\n        if (!path.node.id || !path.node.id.name) {\n          return;\n        }\n        if (isKnownIncompatiblePluginFromState(state)) {\n          return;\n        }\n\n        functionBodyPushAttributes(\n          state.opts[\"annotate-fragments\"] === true,\n          t,\n          path,\n          path.node.id.name,\n          sourceFileNameFromState(state),\n          attributeNamesFromState(state),\n          state.opts.ignoredComponents ?? []\n        );\n      },\n      ArrowFunctionExpression(path, state) {\n        // We're expecting a `VariableDeclarator` like `const MyComponent =`\n        const parent = path.parent;\n\n        if (\n          !parent ||\n          !(\"id\" in parent) ||\n          !parent.id ||\n          !(\"name\" in parent.id) ||\n          !parent.id.name\n        ) {\n          return;\n        }\n\n        if (isKnownIncompatiblePluginFromState(state)) {\n          return;\n        }\n\n        functionBodyPushAttributes(\n          state.opts[\"annotate-fragments\"] === true,\n          t,\n          path,\n          parent.id.name,\n          sourceFileNameFromState(state),\n          attributeNamesFromState(state),\n          state.opts.ignoredComponents ?? []\n        );\n      },\n      ClassDeclaration(path, state) {\n        const name = path.get(\"id\");\n        const properties = path.get(\"body\").get(\"body\");\n        const render = properties.find((prop) => {\n          return prop.isClassMethod() && prop.get(\"key\").isIdentifier({ name: \"render\" });\n        });\n\n        if (!render || !render.traverse || isKnownIncompatiblePluginFromState(state)) {\n          return;\n        }\n\n        const ignoredComponents = state.opts.ignoredComponents ?? [];\n\n        render.traverse({\n          ReturnStatement(returnStatement) {\n            const arg = returnStatement.get(\"argument\");\n\n            if (!arg.isJSXElement() && !arg.isJSXFragment()) {\n              return;\n            }\n\n            processJSX(\n              state.opts[\"annotate-fragments\"] === true,\n              t,\n              arg,\n              name.node && name.node.name,\n              sourceFileNameFromState(state),\n              attributeNamesFromState(state),\n              ignoredComponents\n            );\n          },\n        });\n      },\n    },\n  };\n}\n\nfunction functionBodyPushAttributes(\n  annotateFragments: boolean,\n  t: typeof Babel.types,\n  path: Babel.NodePath<Babel.types.Function>,\n  componentName: string,\n  sourceFileName: string | undefined,\n  attributeNames: string[],\n  ignoredComponents: string[]\n) {\n  let jsxNode: Babel.NodePath;\n\n  const functionBody = path.get(\"body\").get(\"body\");\n\n  if (\n    !(\"length\" in functionBody) &&\n    functionBody.parent &&\n    (functionBody.parent.type === \"JSXElement\" || functionBody.parent.type === \"JSXFragment\")\n  ) {\n    const maybeJsxNode = functionBody.find((c) => {\n      return c.type === \"JSXElement\" || c.type === \"JSXFragment\";\n    });\n\n    if (!maybeJsxNode) {\n      return;\n    }\n\n    jsxNode = maybeJsxNode;\n  } else {\n    const returnStatement = functionBody.find((c) => {\n      return c.type === \"ReturnStatement\";\n    });\n    if (!returnStatement) {\n      return;\n    }\n\n    const arg = returnStatement.get(\"argument\");\n    if (!arg) {\n      return;\n    }\n\n    if (Array.isArray(arg)) {\n      return;\n    }\n\n    // Handle the case of a function body returning a ternary operation.\n    // `return (maybeTrue ? '' : (<SubComponent />))`\n    if (arg.isConditionalExpression()) {\n      const consequent = arg.get(\"consequent\");\n      if (consequent.isJSXFragment() || consequent.isJSXElement()) {\n        processJSX(\n          annotateFragments,\n          t,\n          consequent,\n          componentName,\n          sourceFileName,\n          attributeNames,\n          ignoredComponents\n        );\n      }\n      const alternate = arg.get(\"alternate\");\n      if (alternate.isJSXFragment() || alternate.isJSXElement()) {\n        processJSX(\n          annotateFragments,\n          t,\n          alternate,\n          componentName,\n          sourceFileName,\n          attributeNames,\n          ignoredComponents\n        );\n      }\n      return;\n    }\n\n    if (!arg.isJSXFragment() && !arg.isJSXElement()) {\n      return;\n    }\n\n    jsxNode = arg;\n  }\n\n  if (!jsxNode) {\n    return;\n  }\n\n  processJSX(\n    annotateFragments,\n    t,\n    jsxNode,\n    componentName,\n    sourceFileName,\n    attributeNames,\n    ignoredComponents\n  );\n}\n\nfunction processJSX(\n  annotateFragments: boolean,\n  t: typeof Babel.types,\n  jsxNode: Babel.NodePath,\n  componentName: string | null,\n  sourceFileName: string | undefined,\n  attributeNames: string[],\n  ignoredComponents: string[]\n) {\n  if (!jsxNode) {\n    return;\n  }\n  // NOTE: 